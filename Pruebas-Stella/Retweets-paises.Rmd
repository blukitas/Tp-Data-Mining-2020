---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

#librerias
```{r}
library(mongolite)
options(gsubfn.engine="R")
library(sqldf)
library(wordcloud2)
library(tidyverse)

```
#datos de mongodb
```{r}
db <- mongo(collection = "retweets", db = "DMUBA")

retweets = mongo(db = "DMUBA", collection = "retweets")

df_retweets = retweets$find()

nrow(df_retweets)

db <- mongo(collection = "users_mongo_covid19", db = "DMUBA")
usuarios = mongo(db = "DMUBA", collection = "users_mongo_covid19")

df_usuarios = usuarios$find()



```

##identificar los usuarios que son generadores de retweets y no estan en el data set de usuarios
#son 8782 usuarios
```{r}
stringsqlj = "select distinct retweet_screen_name from df_retweets where retweet_screen_name not in (select screen_name from df_usuarios)"
retweetotautor = sqldf(stringsqlj)
nrow(retweetotautor)
```
##identificar los usuarios que estan en data set de usuarios y fueron retweeteados
#son 2171 usuarios

```{r}
stringsqlk = "select * from df_retweets where retweet_screen_name in (select screen_name from df_usuarios)"
retweetotautorok = sqldf(stringsqlk)
nrow(retweetotautorok)
```
##grafico de totales de retweet por usuarios (solo dataset de usuarios retweeteados)  - 2717 usuarios), tendria que ser el grupo a identificar al utilizar el data set de usuarios

```{r}
stringsqll = "select retweet_screen_name, count(*) as total from df_retweets where retweet_screen_name in (select screen_name from df_usuarios) group by retweet_screen_name order by 2 desc"
retweetotautoroktot = sqldf(stringsqll)
wordcloud2(data=retweetotautoroktot, size=0.2, color='random-dark')
```


#grafico de totales de retweet por usuarios (todos los usuarios: dataset de usuarios mas los que solo estan en retweet)  - 21286 usuarios
```{r}
stringsqlm = "select retweet_screen_name, count(*) as total from df_retweets group by retweet_screen_name order by 2 desc"
retweetotautoroktotodos = sqldf(stringsqlm)
wordcloud2(data=retweetotautoroktotodos, size=0.2, color='random-dark')
```
#completar tipo: politica, normal, medios en todos los retweets (21286 filas )
#se agregan las columnas a "prueba " 

```{r}
prueba <- df_retweets
```

#data frame de words a buscar 
```{r}
noticias_words<- data.frame(word=c('periodista','journalist','escritor','comunicador','locutor','reportero','noticia','newspaper','periódico','revista','@Revista','informativo','información','telediario','televisión','diario online','cuenta oficial de el mundo','periodismo','cuenta oficial de página/12','diario digital','medio digital','diario'))

politica_words<- data.frame(word=c('gobernador','presidente del estado','presidente de la república','ministerio de salud','Vicepresidencia','diputado','presidencia','ministro','senador','embajador','jefe de Gobierno','ministerio'))
                                   
politica_name<- data.frame(words=c('nayibbukele','felipecalderon'))
```

#completar el tipo y barplot
#la gran mayoria queda como "normal"
```{r}
prueba$tipo<- 'NN'
for (i in noticias_words$word) {
  prueba$tipo<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'MEDIOS',prueba$tipo)
}

for (i in politica_words$word) {
  prueba$tipo<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'POLITICA',prueba$tipo)
}

for (i in politica_name$word) {
  prueba$tipo<- ifelse(grepl(i, str_to_lower(prueba$retweet_screen_name), fixed = TRUE), 'POLITICA',prueba$tipo)
}


prueba$tipo<- ifelse(grepl('nn', str_to_lower(prueba$tipo), fixed = TRUE), 'NORMAL',prueba$tipo)

barplot(table(prueba$tipo))

```

#completar pais: argentina, cuba, mexico, usa, chile, venezuela y resto del mundo en todos los retweets (21286 filas ). La mayoria queda como el resto del mundo. Se debe ampliar el set de word a buscar
#se agregan las columnas a "prueba " 
#data frame de words a buscar 

```{r}
argentina_words<- data.frame(words=c('argentin','buenos aires','bs as','jujuy','vicente lopez'))
mexico_words<- data.frame(words=c('mexic','méxic','cdmx','cozumel'))
venezuela_words<- data.frame(words=c('venezuela','venezolan'))
chile_words<- data.frame(words=c('chile'))
cuba_words<- data.frame(words=c('cuba'))
usa_words<- data.frame(words=c('united states','estadosunidos','eeuu','Washington','Washington','texas'))

```
#completar la columna pais
#primero se reemplaza si se encuentra la "word" en location, luego se sigue por description y text, en ese orden de jerarquia

```{r}
prueba$pais<- "NN"

for (i in argentina_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'ARGENTINA',prueba$pais)
}

for (i in mexico_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'MEXICO',prueba$pais)
}

for (i in venezuela_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'VENEZUELA',prueba$pais)
}

for (i in chile_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'CHILE',prueba$pais)
}


for (i in cuba_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'CUBA',prueba$pais)
}
for (i in usa_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_location), fixed = TRUE), 'ESTADOS UNIDOS',prueba$pais)
}


for (i in argentina_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'ARGENTINA',prueba$pais)
}

for (i in mexico_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'MEXICO',prueba$pais)
}

for (i in venezuela_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'VENEZUELA',prueba$pais)
}

for (i in chile_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'CHILE',prueba$pais)

}

for (i in cuba_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'CUBA',prueba$pais)
  
}

for (i in usa_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_description), fixed = TRUE), 'ESTADOS UNIDOS',prueba$pais)
}


#TEXT

for (i in argentina_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'ARGENTINA',prueba$pais)
}

for (i in mexico_words$word) {
    prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'MEXICO',prueba$pais)
}

for (i in venezuela_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'VENEZUELA',prueba$pais)
}

for (i in chile_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'CHILE',prueba$pais)
}

for (i in cuba_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'CUBA',prueba$pais)
}

for (i in usa_words$word) {
  prueba$pais<- ifelse(grepl(i, str_to_lower(prueba$retweet_text), fixed = TRUE), 'ESTADOS UNIDOS',prueba$pais)
  
}


prueba$pais<- ifelse(grepl('nn', str_to_lower(prueba$pais), fixed = TRUE), 'RESTO DEL MUNDO',prueba$pais)
barplot(table(prueba$pais))

```

#ranking
```{r}
stringsqlp = "select retweet_screen_name,pais,tipo,count(*) as total from prueba group by retweet_screen_name,pais,tipo order by 2,4 desc"
topten = sqldf(stringsqlp)



``



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
